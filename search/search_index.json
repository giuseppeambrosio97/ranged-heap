{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RangedHeap","text":"<p>Welcome to the RangedHeap documentation! This documentation provides an overview of the RangedHeap data structure, its methods, and examples of its usage.</p>"},{"location":"#what-is-rangedheap","title":"What is RangedHeap?","text":"<p>RangedHeap is a data structure designed to manage a collection of choices associated with integer values within a specified range [0, k]. It supports efficient operations for adding, deleting, and retrieving choices based on their integer values.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Efficient Choice Management: Manage choices efficiently within a specified integer range.</li> <li>Dynamic Updates: Support dynamic updates to the heap as choices change.</li> <li>Optimized Retrieval: Quickly retrieve the best choice based on specified criteria (minimum or maximum).</li> </ul>"},{"location":"#how-to-use","title":"How to Use","text":"<p>The RangedHeap is particularly useful for implementing algorithms that require optimal selection from a set of integer-ranged choices, such as greedy algorithms.</p>"},{"location":"#example-usage","title":"Example Usage","text":"<pre><code>import ranged_heap as rh\n\nchoices = [(1, 4), (2, 3), (3, 5), (0, 6), (5, 7), (8, 9)]\nk = max(end for _, end in choices)\nranged_heap = rh.RangedHeap(k, choices)\n</code></pre>"},{"location":"api/bisectw/","title":"bisectw","text":"<p>Wrappers around bisect python standard library.</p>"},{"location":"api/bisectw/#ranged_heap.bisectw.bs_add","title":"<code>bs_add(a, x)</code>","text":"<p>Adds <code>x</code> to the sorted list <code>a</code> while maintaining sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>List[int]</code> <p>Sorted list of int numbers.</p> required <code>x</code> <code>int</code> <p>Element to be added to <code>a</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index where <code>x</code> was inserted.</p> Time Complexity <p>O(log n + n), where n is the length of list <code>a</code>.</p> Source code in <code>ranged_heap/bisectw.py</code> <pre><code>def bs_add(a: List[int], x: int) -&gt; int:\n    \"\"\"Adds `x` to the sorted list `a` while maintaining sorted order.\n\n    Args:\n        a (List[int]): Sorted list of int numbers.\n        x (int): Element to be added to `a`.\n\n    Returns:\n        int: Index where `x` was inserted.\n\n    Time Complexity:\n        O(log n + n), where n is the length of list `a`.\n    \"\"\"\n    pos = bisect_left(a, x)  # O(log n)\n    insort_left(a, x)  # O(n)\n    return pos\n</code></pre>"},{"location":"api/bisectw/#ranged_heap.bisectw.bs_delete","title":"<code>bs_delete(a, x)</code>","text":"<p>Deletes the first occurrence of <code>x</code> from the sorted list <code>a</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>List[int]</code> <p>Sorted list of int numbers.</p> required <code>x</code> <code>int</code> <p>Element to be deleted from <code>a</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the deleted element if found, otherwise -1.</p> Time Complexity <p>O(log n + n), where n is the length of list <code>a</code>.</p> Source code in <code>ranged_heap/bisectw.py</code> <pre><code>def bs_delete(a: List[int], x: int) -&gt; int:\n    \"\"\"Deletes the first occurrence of `x` from the sorted list `a`.\n\n    Args:\n        a (List[int]): Sorted list of int numbers.\n        x (int): Element to be deleted from `a`.\n\n    Returns:\n        int: Index of the deleted element if found, otherwise -1.\n\n    Time Complexity:\n        O(log n + n), where n is the length of list `a`.\n    \"\"\"\n    pos = bisect_left(a, x)  # O(log n)\n    if pos &lt; len(a) and a[pos] == x:\n        del a[pos]  # O(n)\n        return pos\n    return -1\n</code></pre>"},{"location":"api/errors/","title":"errors","text":"<p>Custom exception raised by RangedHeap.</p>"},{"location":"api/errors/#ranged_heap.errors.ChoiceNotFoundError","title":"<code>ChoiceNotFoundError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when attempting to delete a choice that doesn't exist in the specified value range.</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class ChoiceNotFoundError(RangedHeapBaseError):\n    \"\"\"Raised when attempting to delete a choice that doesn't exist in the specified value range.\"\"\"\n\n    default_message: str = \"Choice {key} not found in value {value}.\"\n\n    def __init__(self, key: str, value: int, message: Optional[str] = None):\n        super().__init__(message, key=key, value=value)\n</code></pre>"},{"location":"api/errors/#ranged_heap.errors.EmptyHeapError","title":"<code>EmptyHeapError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when trying to pop or get the best choice from an empty heap.</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class EmptyHeapError(RangedHeapBaseError):\n    \"\"\"Raised when trying to pop or get the best choice from an empty heap.\"\"\"\n\n    default_message: str = \"The Ranged Heap is empty!\"\n</code></pre>"},{"location":"api/errors/#ranged_heap.errors.InvalidChoiceError","title":"<code>InvalidChoiceError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when attempting to add or adjust a choice with an invalid value (out of range).</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class InvalidChoiceError(RangedHeapBaseError):\n    \"\"\"Raised when attempting to add or adjust a choice with an invalid value (out of range).\"\"\"\n\n    default_message: str = \"Value {value} is out of range.\"\n\n    def __init__(self, value: int, message: Optional[str] = None):\n        super().__init__(message, value=value)\n</code></pre>"},{"location":"api/errors/#ranged_heap.errors.InvalidRangeError","title":"<code>InvalidRangeError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when the range k is less than 0.</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class InvalidRangeError(RangedHeapBaseError):\n    \"\"\"Raised when the range k is less than 0.\"\"\"\n\n    default_message: str = \"k must be greater or equal to 0.\"\n</code></pre>"},{"location":"api/errors/#ranged_heap.errors.RangedHeapBaseError","title":"<code>RangedHeapBaseError</code>","text":"<p>               Bases: <code>ABC</code>, <code>Exception</code></p> <p>Base class for other exceptions with default error message.</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class RangedHeapBaseError(abc.ABC, Exception):\n    \"\"\"Base class for other exceptions with default error message.\"\"\"\n\n    default_message: str = \"An error occurred.\"\n\n    def __init__(self, message: Optional[str] = None, **kwargs):\n        if message is None:\n            message = self.default_message.format(**kwargs)\n        super().__init__(message)\n</code></pre>"},{"location":"api/ranged_heap/","title":"RangedHeap","text":"<p>Implementation of the RangedHeap data structure.</p>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap","title":"<code>RangedHeap</code>","text":"<p>RangedHeap is a data structure that maintains a collection of choices associated with integer values within a specified range.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>int</code> <p>The range of values a choice can have.</p> <code>best_id</code> <code>int</code> <p>Index indicating whether to return the min or max value choice.</p> <code>size</code> <code>int</code> <p>Number of choices currently in the heap.</p> <code>ranged</code> <code>List[Set]</code> <p>List of sets where each set contains choices for a specific value.</p> <code>actual_value_ranged</code> <code>List</code> <p>List of actual values present in the heap.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>int, choices: List[Tuple[Any, int]], min_: bool = True): Initializes a RangedHeap instance.</p> <code>pop_best</code> <p>Removes and returns the best choice from the heap.</p> <code>_pop_best_twins</code> <p>Helper method to remove and return the best choice.</p> <code>get_best</code> <p>Returns the best choice from the heap without removing it.</p> <code>_get_best_twins</code> <p>Helper method to return the best choice without removing it.</p> <code>delete_choice</code> <p>Any, value: int) -&gt; None: Deletes a specific choice from the heap.</p> <code>add_choice</code> <p>Any, value: int) -&gt; None: Adds a new choice to the heap.</p> <code>adjust_choice</code> <p>Any, old_value: int, new_value: int) -&gt; None: Adjusts the value of an existing choice in the heap.</p> <code>__is_invalid_choice</code> <p>int) -&gt; bool: Checks if a value is invalid.</p> <code>__str__</code> <p>Returns a string representation of the heap.</p> <code>__len__</code> <p>Returns the number of choices in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>class RangedHeap:\n    \"\"\"RangedHeap is a data structure that maintains a collection of choices associated with integer values within a specified range.\n\n    Attributes:\n        k (int): The range of values a choice can have.\n        best_id (int): Index indicating whether to return the min or max value choice.\n        size (int): Number of choices currently in the heap.\n        ranged (List[Set]): List of sets where each set contains choices for a specific value.\n        actual_value_ranged (List): List of actual values present in the heap.\n\n    Methods:\n        __init__(self, k: int, choices: List[Tuple[Any, int]], min_: bool = True):\n            Initializes a RangedHeap instance.\n\n        pop_best(self) -&gt; Any:\n            Removes and returns the best choice from the heap.\n\n        _pop_best_twins(self) -&gt; Any:\n            Helper method to remove and return the best choice.\n\n        get_best(self) -&gt; Any:\n            Returns the best choice from the heap without removing it.\n\n        _get_best_twins(self) -&gt; Any:\n            Helper method to return the best choice without removing it.\n\n        delete_choice(self, key: Any, value: int) -&gt; None:\n            Deletes a specific choice from the heap.\n\n        add_choice(self, key: Any, value: int) -&gt; None:\n            Adds a new choice to the heap.\n\n        adjust_choice(self, key: Any, old_value: int, new_value: int) -&gt; None:\n            Adjusts the value of an existing choice in the heap.\n\n        __is_invalid_choice(self, value: int) -&gt; bool:\n            Checks if a value is invalid.\n\n        __str__(self) -&gt; str:\n            Returns a string representation of the heap.\n\n        __len__(self) -&gt; int:\n            Returns the number of choices in the heap.\n    \"\"\"\n\n    def __init__(self, k: int, choices: List[Tuple[Any, int]], min_: bool = True):\n        \"\"\"Initialize a RangedHeap.\n\n        Args:\n            k (int): A positive integer indicating the range of values a choice can have.\n            choices (List[Tuple[Any, int]]): A list of pairs where each pair contains:\n                - A key associated with the choice (Any).\n                - A value associated with the choice (int).\n            min_ (bool, optional): If True, get_best() will return the key with the lowest value.\n                                   If False, get_best() will return the key with the highest value.\n                                   Defaults to True.\n        \"\"\"\n        if k &lt; 0:\n            raise InvalidRangeError()\n\n        self.k = k\n        self.best_id = 0 if min_ else -1\n        self.size = len(choices)\n        self.ranged: List[Set] = [set() for _ in range(k + 1)]\n        self.actual_value_ranged = []\n\n        for choice in choices:\n            self.ranged[choice[1]].add(choice[0])\n\n        for idx, choices_id in enumerate(self.ranged):\n            if choices_id:\n                self.actual_value_ranged.append(idx)\n\n    def pop_best(self) -&gt; Any:\n        \"\"\"Remove and return the best choice from the heap.\n\n        Returns:\n            Any: The key of the best choice.\n\n        Raises:\n            EmptyHeapError: If the heap is empty.\n        \"\"\"\n        if self.size &gt;= 1:\n            choice_to_pick = self._pop_best_twins()\n            self.size -= 1\n            if not self.ranged[self.actual_value_ranged[self.best_id]]:\n                del self.actual_value_ranged[self.best_id]\n            return choice_to_pick\n\n        raise EmptyHeapError()\n\n    def _pop_best_twins(self) -&gt; Any:\n        \"\"\"Helper method to remove and return the best choice.\n\n        Returns:\n            Any: The key of the best choice.\n        \"\"\"\n        choice_to_pick = list(self.ranged[self.actual_value_ranged[self.best_id]])[0]\n        self.ranged[self.actual_value_ranged[self.best_id]].remove(choice_to_pick)\n        return choice_to_pick\n\n    def get_best(self) -&gt; Any:\n        \"\"\"Return the best choice from the heap without removing it.\n\n        Returns:\n            Any: The key of the best choice.\n\n        Raises:\n            EmptyHeapError: If the heap is empty.\n        \"\"\"\n        if self.size &gt;= 1:\n            return self._get_best_twins()\n\n        raise EmptyHeapError()\n\n    def _get_best_twins(self) -&gt; Any:\n        \"\"\"Helper method to return the best choice without removing it.\n\n        Returns:\n            Any: The key of the best choice.\n        \"\"\"\n        return list(self.ranged[self.actual_value_ranged[self.best_id]])[0]\n\n    def delete_choice(self, key: Any, value: int) -&gt; None:\n        \"\"\"Delete a specific choice from the heap.\n\n        Args:\n            key (Any): The key of the choice to be deleted.\n            value (int): The value associated with the choice.\n\n        Raises:\n            InvalidChoiceError: If the value is invalid.\n            ChoiceNotFoundError: If the choice is not found in the heap.\n        \"\"\"\n        if self.__is_invalid_choice(value):\n            raise InvalidChoiceError(value=value)\n\n        if key not in self.ranged[value]:\n            raise ChoiceNotFoundError(key, value)\n\n        self.ranged[value].remove(key)\n        self.size -= 1\n\n        if not self.ranged[value]:\n            bs_delete(self.actual_value_ranged, value)\n\n    def add_choice(self, key: Any, value: int) -&gt; None:\n        \"\"\"Add a new choice to the heap.\n\n        Args:\n            key (Any): The key of the choice to be added.\n            value (int): The value associated with the choice.\n\n        Raises:\n            InvalidChoiceError: If the value is invalid.\n        \"\"\"\n        if self.__is_invalid_choice(value):\n            raise InvalidChoiceError(value=value)\n\n        if not self.ranged[value]:\n            bs_add(self.actual_value_ranged, value)\n        self.ranged[value].add(key)\n        self.size += 1\n\n    def adjust_choice(self, key: Any, old_value: int, new_value: int) -&gt; None:\n        \"\"\"Adjust the value of an existing choice in the heap.\n\n        Args:\n            key (Any): The key of the choice to be adjusted.\n            old_value (int): The current value of the choice.\n            new_value (int): The new value to be assigned to the choice.\n\n        Raises:\n            InvalidChoiceError: If either old_value or new_value is invalid.\n            ChoiceNotFoundError: If the choice is not found in the heap.\n        \"\"\"\n        if self.__is_invalid_choice(old_value):\n            raise InvalidChoiceError(value=old_value)\n\n        if self.__is_invalid_choice(new_value):\n            raise InvalidChoiceError(value=new_value)\n\n        if key not in self.ranged[old_value]:\n            raise ChoiceNotFoundError(key, old_value)\n\n        self.ranged[old_value].remove(key)\n\n        bs_delete(self.actual_value_ranged, old_value)\n\n        if not self.ranged[new_value]:\n            bs_add(self.actual_value_ranged, new_value)\n        self.ranged[new_value].add(key)\n\n    def __is_invalid_choice(self, value: int) -&gt; bool:\n        \"\"\"Check if a value is invalid.\n\n        Args:\n            value (int): The value to check.\n\n        Returns:\n            bool: True if the value is invalid, False otherwise.\n        \"\"\"\n        return value &lt; 0 or value &gt; self.k\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the heap.\n\n        Returns:\n            str: String representation of the heap.\n        \"\"\"\n        s = \"\"\n        for idx, choices_per_value in enumerate(self.ranged):\n            choices_key = \" \".join(choices_per_value)\n            s += f\"[{idx}] -&gt; {{{choices_key}}}\\n\"\n        return s\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of choices in the heap.\n\n        Returns:\n            int: The number of choices in the heap.\n        \"\"\"\n        return self.size\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.__init__","title":"<code>__init__(k, choices, min_=True)</code>","text":"<p>Initialize a RangedHeap.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>A positive integer indicating the range of values a choice can have.</p> required <code>choices</code> <code>List[Tuple[Any, int]]</code> <p>A list of pairs where each pair contains: - A key associated with the choice (Any). - A value associated with the choice (int).</p> required <code>min_</code> <code>bool</code> <p>If True, get_best() will return the key with the lowest value.                    If False, get_best() will return the key with the highest value.                    Defaults to True.</p> <code>True</code> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __init__(self, k: int, choices: List[Tuple[Any, int]], min_: bool = True):\n    \"\"\"Initialize a RangedHeap.\n\n    Args:\n        k (int): A positive integer indicating the range of values a choice can have.\n        choices (List[Tuple[Any, int]]): A list of pairs where each pair contains:\n            - A key associated with the choice (Any).\n            - A value associated with the choice (int).\n        min_ (bool, optional): If True, get_best() will return the key with the lowest value.\n                               If False, get_best() will return the key with the highest value.\n                               Defaults to True.\n    \"\"\"\n    if k &lt; 0:\n        raise InvalidRangeError()\n\n    self.k = k\n    self.best_id = 0 if min_ else -1\n    self.size = len(choices)\n    self.ranged: List[Set] = [set() for _ in range(k + 1)]\n    self.actual_value_ranged = []\n\n    for choice in choices:\n        self.ranged[choice[1]].add(choice[0])\n\n    for idx, choices_id in enumerate(self.ranged):\n        if choices_id:\n            self.actual_value_ranged.append(idx)\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.__is_invalid_choice","title":"<code>__is_invalid_choice(value)</code>","text":"<p>Check if a value is invalid.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is invalid, False otherwise.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __is_invalid_choice(self, value: int) -&gt; bool:\n    \"\"\"Check if a value is invalid.\n\n    Args:\n        value (int): The value to check.\n\n    Returns:\n        bool: True if the value is invalid, False otherwise.\n    \"\"\"\n    return value &lt; 0 or value &gt; self.k\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of choices in the heap.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of choices in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of choices in the heap.\n\n    Returns:\n        int: The number of choices in the heap.\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the heap.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the heap.\n\n    Returns:\n        str: String representation of the heap.\n    \"\"\"\n    s = \"\"\n    for idx, choices_per_value in enumerate(self.ranged):\n        choices_key = \" \".join(choices_per_value)\n        s += f\"[{idx}] -&gt; {{{choices_key}}}\\n\"\n    return s\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.add_choice","title":"<code>add_choice(key, value)</code>","text":"<p>Add a new choice to the heap.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key of the choice to be added.</p> required <code>value</code> <code>int</code> <p>The value associated with the choice.</p> required <p>Raises:</p> Type Description <code>InvalidChoiceError</code> <p>If the value is invalid.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def add_choice(self, key: Any, value: int) -&gt; None:\n    \"\"\"Add a new choice to the heap.\n\n    Args:\n        key (Any): The key of the choice to be added.\n        value (int): The value associated with the choice.\n\n    Raises:\n        InvalidChoiceError: If the value is invalid.\n    \"\"\"\n    if self.__is_invalid_choice(value):\n        raise InvalidChoiceError(value=value)\n\n    if not self.ranged[value]:\n        bs_add(self.actual_value_ranged, value)\n    self.ranged[value].add(key)\n    self.size += 1\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.adjust_choice","title":"<code>adjust_choice(key, old_value, new_value)</code>","text":"<p>Adjust the value of an existing choice in the heap.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key of the choice to be adjusted.</p> required <code>old_value</code> <code>int</code> <p>The current value of the choice.</p> required <code>new_value</code> <code>int</code> <p>The new value to be assigned to the choice.</p> required <p>Raises:</p> Type Description <code>InvalidChoiceError</code> <p>If either old_value or new_value is invalid.</p> <code>ChoiceNotFoundError</code> <p>If the choice is not found in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def adjust_choice(self, key: Any, old_value: int, new_value: int) -&gt; None:\n    \"\"\"Adjust the value of an existing choice in the heap.\n\n    Args:\n        key (Any): The key of the choice to be adjusted.\n        old_value (int): The current value of the choice.\n        new_value (int): The new value to be assigned to the choice.\n\n    Raises:\n        InvalidChoiceError: If either old_value or new_value is invalid.\n        ChoiceNotFoundError: If the choice is not found in the heap.\n    \"\"\"\n    if self.__is_invalid_choice(old_value):\n        raise InvalidChoiceError(value=old_value)\n\n    if self.__is_invalid_choice(new_value):\n        raise InvalidChoiceError(value=new_value)\n\n    if key not in self.ranged[old_value]:\n        raise ChoiceNotFoundError(key, old_value)\n\n    self.ranged[old_value].remove(key)\n\n    bs_delete(self.actual_value_ranged, old_value)\n\n    if not self.ranged[new_value]:\n        bs_add(self.actual_value_ranged, new_value)\n    self.ranged[new_value].add(key)\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.delete_choice","title":"<code>delete_choice(key, value)</code>","text":"<p>Delete a specific choice from the heap.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key of the choice to be deleted.</p> required <code>value</code> <code>int</code> <p>The value associated with the choice.</p> required <p>Raises:</p> Type Description <code>InvalidChoiceError</code> <p>If the value is invalid.</p> <code>ChoiceNotFoundError</code> <p>If the choice is not found in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def delete_choice(self, key: Any, value: int) -&gt; None:\n    \"\"\"Delete a specific choice from the heap.\n\n    Args:\n        key (Any): The key of the choice to be deleted.\n        value (int): The value associated with the choice.\n\n    Raises:\n        InvalidChoiceError: If the value is invalid.\n        ChoiceNotFoundError: If the choice is not found in the heap.\n    \"\"\"\n    if self.__is_invalid_choice(value):\n        raise InvalidChoiceError(value=value)\n\n    if key not in self.ranged[value]:\n        raise ChoiceNotFoundError(key, value)\n\n    self.ranged[value].remove(key)\n    self.size -= 1\n\n    if not self.ranged[value]:\n        bs_delete(self.actual_value_ranged, value)\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.get_best","title":"<code>get_best()</code>","text":"<p>Return the best choice from the heap without removing it.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The key of the best choice.</p> <p>Raises:</p> Type Description <code>EmptyHeapError</code> <p>If the heap is empty.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def get_best(self) -&gt; Any:\n    \"\"\"Return the best choice from the heap without removing it.\n\n    Returns:\n        Any: The key of the best choice.\n\n    Raises:\n        EmptyHeapError: If the heap is empty.\n    \"\"\"\n    if self.size &gt;= 1:\n        return self._get_best_twins()\n\n    raise EmptyHeapError()\n</code></pre>"},{"location":"api/ranged_heap/#ranged_heap.ranged_heap.RangedHeap.pop_best","title":"<code>pop_best()</code>","text":"<p>Remove and return the best choice from the heap.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The key of the best choice.</p> <p>Raises:</p> Type Description <code>EmptyHeapError</code> <p>If the heap is empty.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def pop_best(self) -&gt; Any:\n    \"\"\"Remove and return the best choice from the heap.\n\n    Returns:\n        Any: The key of the best choice.\n\n    Raises:\n        EmptyHeapError: If the heap is empty.\n    \"\"\"\n    if self.size &gt;= 1:\n        choice_to_pick = self._pop_best_twins()\n        self.size -= 1\n        if not self.ranged[self.actual_value_ranged[self.best_id]]:\n            del self.actual_value_ranged[self.best_id]\n        return choice_to_pick\n\n    raise EmptyHeapError()\n</code></pre>"},{"location":"api/ranged_heap_all/","title":"API Reference","text":""},{"location":"api/ranged_heap_all/#ranged_heap.ChoiceNotFoundError","title":"<code>ChoiceNotFoundError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when attempting to delete a choice that doesn't exist in the specified value range.</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class ChoiceNotFoundError(RangedHeapBaseError):\n    \"\"\"Raised when attempting to delete a choice that doesn't exist in the specified value range.\"\"\"\n\n    default_message: str = \"Choice {key} not found in value {value}.\"\n\n    def __init__(self, key: str, value: int, message: Optional[str] = None):\n        super().__init__(message, key=key, value=value)\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.EmptyHeapError","title":"<code>EmptyHeapError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when trying to pop or get the best choice from an empty heap.</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class EmptyHeapError(RangedHeapBaseError):\n    \"\"\"Raised when trying to pop or get the best choice from an empty heap.\"\"\"\n\n    default_message: str = \"The Ranged Heap is empty!\"\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.InvalidChoiceError","title":"<code>InvalidChoiceError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when attempting to add or adjust a choice with an invalid value (out of range).</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class InvalidChoiceError(RangedHeapBaseError):\n    \"\"\"Raised when attempting to add or adjust a choice with an invalid value (out of range).\"\"\"\n\n    default_message: str = \"Value {value} is out of range.\"\n\n    def __init__(self, value: int, message: Optional[str] = None):\n        super().__init__(message, value=value)\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.InvalidRangeError","title":"<code>InvalidRangeError</code>","text":"<p>               Bases: <code>RangedHeapBaseError</code></p> <p>Raised when the range k is less than 0.</p> Source code in <code>ranged_heap/errors.py</code> <pre><code>class InvalidRangeError(RangedHeapBaseError):\n    \"\"\"Raised when the range k is less than 0.\"\"\"\n\n    default_message: str = \"k must be greater or equal to 0.\"\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap","title":"<code>RangedHeap</code>","text":"<p>RangedHeap is a data structure that maintains a collection of choices associated with integer values within a specified range.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>int</code> <p>The range of values a choice can have.</p> <code>best_id</code> <code>int</code> <p>Index indicating whether to return the min or max value choice.</p> <code>size</code> <code>int</code> <p>Number of choices currently in the heap.</p> <code>ranged</code> <code>List[Set]</code> <p>List of sets where each set contains choices for a specific value.</p> <code>actual_value_ranged</code> <code>List</code> <p>List of actual values present in the heap.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>int, choices: List[Tuple[Any, int]], min_: bool = True): Initializes a RangedHeap instance.</p> <code>pop_best</code> <p>Removes and returns the best choice from the heap.</p> <code>_pop_best_twins</code> <p>Helper method to remove and return the best choice.</p> <code>get_best</code> <p>Returns the best choice from the heap without removing it.</p> <code>_get_best_twins</code> <p>Helper method to return the best choice without removing it.</p> <code>delete_choice</code> <p>Any, value: int) -&gt; None: Deletes a specific choice from the heap.</p> <code>add_choice</code> <p>Any, value: int) -&gt; None: Adds a new choice to the heap.</p> <code>adjust_choice</code> <p>Any, old_value: int, new_value: int) -&gt; None: Adjusts the value of an existing choice in the heap.</p> <code>__is_invalid_choice</code> <p>int) -&gt; bool: Checks if a value is invalid.</p> <code>__str__</code> <p>Returns a string representation of the heap.</p> <code>__len__</code> <p>Returns the number of choices in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>class RangedHeap:\n    \"\"\"RangedHeap is a data structure that maintains a collection of choices associated with integer values within a specified range.\n\n    Attributes:\n        k (int): The range of values a choice can have.\n        best_id (int): Index indicating whether to return the min or max value choice.\n        size (int): Number of choices currently in the heap.\n        ranged (List[Set]): List of sets where each set contains choices for a specific value.\n        actual_value_ranged (List): List of actual values present in the heap.\n\n    Methods:\n        __init__(self, k: int, choices: List[Tuple[Any, int]], min_: bool = True):\n            Initializes a RangedHeap instance.\n\n        pop_best(self) -&gt; Any:\n            Removes and returns the best choice from the heap.\n\n        _pop_best_twins(self) -&gt; Any:\n            Helper method to remove and return the best choice.\n\n        get_best(self) -&gt; Any:\n            Returns the best choice from the heap without removing it.\n\n        _get_best_twins(self) -&gt; Any:\n            Helper method to return the best choice without removing it.\n\n        delete_choice(self, key: Any, value: int) -&gt; None:\n            Deletes a specific choice from the heap.\n\n        add_choice(self, key: Any, value: int) -&gt; None:\n            Adds a new choice to the heap.\n\n        adjust_choice(self, key: Any, old_value: int, new_value: int) -&gt; None:\n            Adjusts the value of an existing choice in the heap.\n\n        __is_invalid_choice(self, value: int) -&gt; bool:\n            Checks if a value is invalid.\n\n        __str__(self) -&gt; str:\n            Returns a string representation of the heap.\n\n        __len__(self) -&gt; int:\n            Returns the number of choices in the heap.\n    \"\"\"\n\n    def __init__(self, k: int, choices: List[Tuple[Any, int]], min_: bool = True):\n        \"\"\"Initialize a RangedHeap.\n\n        Args:\n            k (int): A positive integer indicating the range of values a choice can have.\n            choices (List[Tuple[Any, int]]): A list of pairs where each pair contains:\n                - A key associated with the choice (Any).\n                - A value associated with the choice (int).\n            min_ (bool, optional): If True, get_best() will return the key with the lowest value.\n                                   If False, get_best() will return the key with the highest value.\n                                   Defaults to True.\n        \"\"\"\n        if k &lt; 0:\n            raise InvalidRangeError()\n\n        self.k = k\n        self.best_id = 0 if min_ else -1\n        self.size = len(choices)\n        self.ranged: List[Set] = [set() for _ in range(k + 1)]\n        self.actual_value_ranged = []\n\n        for choice in choices:\n            self.ranged[choice[1]].add(choice[0])\n\n        for idx, choices_id in enumerate(self.ranged):\n            if choices_id:\n                self.actual_value_ranged.append(idx)\n\n    def pop_best(self) -&gt; Any:\n        \"\"\"Remove and return the best choice from the heap.\n\n        Returns:\n            Any: The key of the best choice.\n\n        Raises:\n            EmptyHeapError: If the heap is empty.\n        \"\"\"\n        if self.size &gt;= 1:\n            choice_to_pick = self._pop_best_twins()\n            self.size -= 1\n            if not self.ranged[self.actual_value_ranged[self.best_id]]:\n                del self.actual_value_ranged[self.best_id]\n            return choice_to_pick\n\n        raise EmptyHeapError()\n\n    def _pop_best_twins(self) -&gt; Any:\n        \"\"\"Helper method to remove and return the best choice.\n\n        Returns:\n            Any: The key of the best choice.\n        \"\"\"\n        choice_to_pick = list(self.ranged[self.actual_value_ranged[self.best_id]])[0]\n        self.ranged[self.actual_value_ranged[self.best_id]].remove(choice_to_pick)\n        return choice_to_pick\n\n    def get_best(self) -&gt; Any:\n        \"\"\"Return the best choice from the heap without removing it.\n\n        Returns:\n            Any: The key of the best choice.\n\n        Raises:\n            EmptyHeapError: If the heap is empty.\n        \"\"\"\n        if self.size &gt;= 1:\n            return self._get_best_twins()\n\n        raise EmptyHeapError()\n\n    def _get_best_twins(self) -&gt; Any:\n        \"\"\"Helper method to return the best choice without removing it.\n\n        Returns:\n            Any: The key of the best choice.\n        \"\"\"\n        return list(self.ranged[self.actual_value_ranged[self.best_id]])[0]\n\n    def delete_choice(self, key: Any, value: int) -&gt; None:\n        \"\"\"Delete a specific choice from the heap.\n\n        Args:\n            key (Any): The key of the choice to be deleted.\n            value (int): The value associated with the choice.\n\n        Raises:\n            InvalidChoiceError: If the value is invalid.\n            ChoiceNotFoundError: If the choice is not found in the heap.\n        \"\"\"\n        if self.__is_invalid_choice(value):\n            raise InvalidChoiceError(value=value)\n\n        if key not in self.ranged[value]:\n            raise ChoiceNotFoundError(key, value)\n\n        self.ranged[value].remove(key)\n        self.size -= 1\n\n        if not self.ranged[value]:\n            bs_delete(self.actual_value_ranged, value)\n\n    def add_choice(self, key: Any, value: int) -&gt; None:\n        \"\"\"Add a new choice to the heap.\n\n        Args:\n            key (Any): The key of the choice to be added.\n            value (int): The value associated with the choice.\n\n        Raises:\n            InvalidChoiceError: If the value is invalid.\n        \"\"\"\n        if self.__is_invalid_choice(value):\n            raise InvalidChoiceError(value=value)\n\n        if not self.ranged[value]:\n            bs_add(self.actual_value_ranged, value)\n        self.ranged[value].add(key)\n        self.size += 1\n\n    def adjust_choice(self, key: Any, old_value: int, new_value: int) -&gt; None:\n        \"\"\"Adjust the value of an existing choice in the heap.\n\n        Args:\n            key (Any): The key of the choice to be adjusted.\n            old_value (int): The current value of the choice.\n            new_value (int): The new value to be assigned to the choice.\n\n        Raises:\n            InvalidChoiceError: If either old_value or new_value is invalid.\n            ChoiceNotFoundError: If the choice is not found in the heap.\n        \"\"\"\n        if self.__is_invalid_choice(old_value):\n            raise InvalidChoiceError(value=old_value)\n\n        if self.__is_invalid_choice(new_value):\n            raise InvalidChoiceError(value=new_value)\n\n        if key not in self.ranged[old_value]:\n            raise ChoiceNotFoundError(key, old_value)\n\n        self.ranged[old_value].remove(key)\n\n        bs_delete(self.actual_value_ranged, old_value)\n\n        if not self.ranged[new_value]:\n            bs_add(self.actual_value_ranged, new_value)\n        self.ranged[new_value].add(key)\n\n    def __is_invalid_choice(self, value: int) -&gt; bool:\n        \"\"\"Check if a value is invalid.\n\n        Args:\n            value (int): The value to check.\n\n        Returns:\n            bool: True if the value is invalid, False otherwise.\n        \"\"\"\n        return value &lt; 0 or value &gt; self.k\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the heap.\n\n        Returns:\n            str: String representation of the heap.\n        \"\"\"\n        s = \"\"\n        for idx, choices_per_value in enumerate(self.ranged):\n            choices_key = \" \".join(choices_per_value)\n            s += f\"[{idx}] -&gt; {{{choices_key}}}\\n\"\n        return s\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of choices in the heap.\n\n        Returns:\n            int: The number of choices in the heap.\n        \"\"\"\n        return self.size\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.__init__","title":"<code>__init__(k, choices, min_=True)</code>","text":"<p>Initialize a RangedHeap.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>A positive integer indicating the range of values a choice can have.</p> required <code>choices</code> <code>List[Tuple[Any, int]]</code> <p>A list of pairs where each pair contains: - A key associated with the choice (Any). - A value associated with the choice (int).</p> required <code>min_</code> <code>bool</code> <p>If True, get_best() will return the key with the lowest value.                    If False, get_best() will return the key with the highest value.                    Defaults to True.</p> <code>True</code> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __init__(self, k: int, choices: List[Tuple[Any, int]], min_: bool = True):\n    \"\"\"Initialize a RangedHeap.\n\n    Args:\n        k (int): A positive integer indicating the range of values a choice can have.\n        choices (List[Tuple[Any, int]]): A list of pairs where each pair contains:\n            - A key associated with the choice (Any).\n            - A value associated with the choice (int).\n        min_ (bool, optional): If True, get_best() will return the key with the lowest value.\n                               If False, get_best() will return the key with the highest value.\n                               Defaults to True.\n    \"\"\"\n    if k &lt; 0:\n        raise InvalidRangeError()\n\n    self.k = k\n    self.best_id = 0 if min_ else -1\n    self.size = len(choices)\n    self.ranged: List[Set] = [set() for _ in range(k + 1)]\n    self.actual_value_ranged = []\n\n    for choice in choices:\n        self.ranged[choice[1]].add(choice[0])\n\n    for idx, choices_id in enumerate(self.ranged):\n        if choices_id:\n            self.actual_value_ranged.append(idx)\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.__is_invalid_choice","title":"<code>__is_invalid_choice(value)</code>","text":"<p>Check if a value is invalid.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is invalid, False otherwise.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __is_invalid_choice(self, value: int) -&gt; bool:\n    \"\"\"Check if a value is invalid.\n\n    Args:\n        value (int): The value to check.\n\n    Returns:\n        bool: True if the value is invalid, False otherwise.\n    \"\"\"\n    return value &lt; 0 or value &gt; self.k\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of choices in the heap.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of choices in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of choices in the heap.\n\n    Returns:\n        int: The number of choices in the heap.\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the heap.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the heap.\n\n    Returns:\n        str: String representation of the heap.\n    \"\"\"\n    s = \"\"\n    for idx, choices_per_value in enumerate(self.ranged):\n        choices_key = \" \".join(choices_per_value)\n        s += f\"[{idx}] -&gt; {{{choices_key}}}\\n\"\n    return s\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.add_choice","title":"<code>add_choice(key, value)</code>","text":"<p>Add a new choice to the heap.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key of the choice to be added.</p> required <code>value</code> <code>int</code> <p>The value associated with the choice.</p> required <p>Raises:</p> Type Description <code>InvalidChoiceError</code> <p>If the value is invalid.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def add_choice(self, key: Any, value: int) -&gt; None:\n    \"\"\"Add a new choice to the heap.\n\n    Args:\n        key (Any): The key of the choice to be added.\n        value (int): The value associated with the choice.\n\n    Raises:\n        InvalidChoiceError: If the value is invalid.\n    \"\"\"\n    if self.__is_invalid_choice(value):\n        raise InvalidChoiceError(value=value)\n\n    if not self.ranged[value]:\n        bs_add(self.actual_value_ranged, value)\n    self.ranged[value].add(key)\n    self.size += 1\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.adjust_choice","title":"<code>adjust_choice(key, old_value, new_value)</code>","text":"<p>Adjust the value of an existing choice in the heap.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key of the choice to be adjusted.</p> required <code>old_value</code> <code>int</code> <p>The current value of the choice.</p> required <code>new_value</code> <code>int</code> <p>The new value to be assigned to the choice.</p> required <p>Raises:</p> Type Description <code>InvalidChoiceError</code> <p>If either old_value or new_value is invalid.</p> <code>ChoiceNotFoundError</code> <p>If the choice is not found in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def adjust_choice(self, key: Any, old_value: int, new_value: int) -&gt; None:\n    \"\"\"Adjust the value of an existing choice in the heap.\n\n    Args:\n        key (Any): The key of the choice to be adjusted.\n        old_value (int): The current value of the choice.\n        new_value (int): The new value to be assigned to the choice.\n\n    Raises:\n        InvalidChoiceError: If either old_value or new_value is invalid.\n        ChoiceNotFoundError: If the choice is not found in the heap.\n    \"\"\"\n    if self.__is_invalid_choice(old_value):\n        raise InvalidChoiceError(value=old_value)\n\n    if self.__is_invalid_choice(new_value):\n        raise InvalidChoiceError(value=new_value)\n\n    if key not in self.ranged[old_value]:\n        raise ChoiceNotFoundError(key, old_value)\n\n    self.ranged[old_value].remove(key)\n\n    bs_delete(self.actual_value_ranged, old_value)\n\n    if not self.ranged[new_value]:\n        bs_add(self.actual_value_ranged, new_value)\n    self.ranged[new_value].add(key)\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.delete_choice","title":"<code>delete_choice(key, value)</code>","text":"<p>Delete a specific choice from the heap.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key of the choice to be deleted.</p> required <code>value</code> <code>int</code> <p>The value associated with the choice.</p> required <p>Raises:</p> Type Description <code>InvalidChoiceError</code> <p>If the value is invalid.</p> <code>ChoiceNotFoundError</code> <p>If the choice is not found in the heap.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def delete_choice(self, key: Any, value: int) -&gt; None:\n    \"\"\"Delete a specific choice from the heap.\n\n    Args:\n        key (Any): The key of the choice to be deleted.\n        value (int): The value associated with the choice.\n\n    Raises:\n        InvalidChoiceError: If the value is invalid.\n        ChoiceNotFoundError: If the choice is not found in the heap.\n    \"\"\"\n    if self.__is_invalid_choice(value):\n        raise InvalidChoiceError(value=value)\n\n    if key not in self.ranged[value]:\n        raise ChoiceNotFoundError(key, value)\n\n    self.ranged[value].remove(key)\n    self.size -= 1\n\n    if not self.ranged[value]:\n        bs_delete(self.actual_value_ranged, value)\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.get_best","title":"<code>get_best()</code>","text":"<p>Return the best choice from the heap without removing it.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The key of the best choice.</p> <p>Raises:</p> Type Description <code>EmptyHeapError</code> <p>If the heap is empty.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def get_best(self) -&gt; Any:\n    \"\"\"Return the best choice from the heap without removing it.\n\n    Returns:\n        Any: The key of the best choice.\n\n    Raises:\n        EmptyHeapError: If the heap is empty.\n    \"\"\"\n    if self.size &gt;= 1:\n        return self._get_best_twins()\n\n    raise EmptyHeapError()\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.RangedHeap.pop_best","title":"<code>pop_best()</code>","text":"<p>Remove and return the best choice from the heap.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The key of the best choice.</p> <p>Raises:</p> Type Description <code>EmptyHeapError</code> <p>If the heap is empty.</p> Source code in <code>ranged_heap/ranged_heap.py</code> <pre><code>def pop_best(self) -&gt; Any:\n    \"\"\"Remove and return the best choice from the heap.\n\n    Returns:\n        Any: The key of the best choice.\n\n    Raises:\n        EmptyHeapError: If the heap is empty.\n    \"\"\"\n    if self.size &gt;= 1:\n        choice_to_pick = self._pop_best_twins()\n        self.size -= 1\n        if not self.ranged[self.actual_value_ranged[self.best_id]]:\n            del self.actual_value_ranged[self.best_id]\n        return choice_to_pick\n\n    raise EmptyHeapError()\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.bs_add","title":"<code>bs_add(a, x)</code>","text":"<p>Adds <code>x</code> to the sorted list <code>a</code> while maintaining sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>List[int]</code> <p>Sorted list of int numbers.</p> required <code>x</code> <code>int</code> <p>Element to be added to <code>a</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index where <code>x</code> was inserted.</p> Time Complexity <p>O(log n + n), where n is the length of list <code>a</code>.</p> Source code in <code>ranged_heap/bisectw.py</code> <pre><code>def bs_add(a: List[int], x: int) -&gt; int:\n    \"\"\"Adds `x` to the sorted list `a` while maintaining sorted order.\n\n    Args:\n        a (List[int]): Sorted list of int numbers.\n        x (int): Element to be added to `a`.\n\n    Returns:\n        int: Index where `x` was inserted.\n\n    Time Complexity:\n        O(log n + n), where n is the length of list `a`.\n    \"\"\"\n    pos = bisect_left(a, x)  # O(log n)\n    insort_left(a, x)  # O(n)\n    return pos\n</code></pre>"},{"location":"api/ranged_heap_all/#ranged_heap.bs_delete","title":"<code>bs_delete(a, x)</code>","text":"<p>Deletes the first occurrence of <code>x</code> from the sorted list <code>a</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>List[int]</code> <p>Sorted list of int numbers.</p> required <code>x</code> <code>int</code> <p>Element to be deleted from <code>a</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the deleted element if found, otherwise -1.</p> Time Complexity <p>O(log n + n), where n is the length of list <code>a</code>.</p> Source code in <code>ranged_heap/bisectw.py</code> <pre><code>def bs_delete(a: List[int], x: int) -&gt; int:\n    \"\"\"Deletes the first occurrence of `x` from the sorted list `a`.\n\n    Args:\n        a (List[int]): Sorted list of int numbers.\n        x (int): Element to be deleted from `a`.\n\n    Returns:\n        int: Index of the deleted element if found, otherwise -1.\n\n    Time Complexity:\n        O(log n + n), where n is the length of list `a`.\n    \"\"\"\n    pos = bisect_left(a, x)  # O(log n)\n    if pos &lt; len(a) and a[pos] == x:\n        del a[pos]  # O(n)\n        return pos\n    return -1\n</code></pre>"},{"location":"development/changelog/","title":"Changelog","text":"<p>\ud83d\udea7 Work in Progress \ud83d\udea7</p> <p>This page is currently being developed and may not be complete.</p> <p>Feel free to contribute to this page! If you have suggestions or would like to help improve it, please contact us.</p>"},{"location":"development/code_of_conduct/","title":"Code of Conduct","text":"<p>\ud83d\udea7 Work in Progress \ud83d\udea7</p> <p>This page is currently being developed and may not be complete.</p> <p>Feel free to contribute to this page! If you have suggestions or would like to help improve it, please contact us.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>\ud83d\udea7 Work in Progress \ud83d\udea7</p> <p>This page is currently being developed and may not be complete.</p> <p>Feel free to contribute to this page! If you have suggestions or would like to help improve it, please contact us.</p>"},{"location":"development/roadmap/","title":"Roadmap","text":"<p>This document outlines the planned future improvements and features for the Ranged Heap library. The following tasks are on our roadmap:</p>"},{"location":"development/roadmap/#parametrize-the-choice-in-rangedheap","title":"[ ] Parametrize the choice in RangedHeap","text":"<p>Enhance the RangedHeap data structure to allow parameterization of choices. This feature will enable users to customize the behavior of the heap according to their specific needs.</p>"},{"location":"development/roadmap/#cicd-with-github-actions","title":"[ ] CICD with GitHub Actions","text":"<p>Set up Continuous Integration and Continuous Deployment (CICD) pipelines using GitHub Actions. This will automate testing, building, and deployment processes, ensuring a smoother and more reliable development workflow.</p>"},{"location":"development/roadmap/#improve-performance-with-crust-binding","title":"[ ] Improve performance with C++/Rust binding","text":"<p>Integrate C++ or Rust bindings to improve the performance of the Ranged Heap library. By leveraging the speed and efficiency of these lower-level languages, we aim to provide faster operations and reduce overhead.</p>"},{"location":"development/roadmap/#add-more-usage-examples","title":"[ ] Add more usage examples","text":"<p>Expand the documentation with additional usage examples. These examples will cover a broader range of scenarios and use cases, helping users to better understand how to effectively utilize the Ranged Heap library.</p>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>To install the ranged_heap library, you can use <code>pip</code>. Run the following command in your terminal:</p> <pre><code>pip install ranged_heap\n</code></pre>"},{"location":"getting_started/introduction/","title":"Introduction","text":"<p>RangedHeap is a data structure that maintains a collection of choices associated with integer values within a specified range. It supports efficient addition, deletion, and retrieval of the best choice (either minimum or maximum).</p> <p>This documentation will guide you through the installation, basic usage, and advanced features of the ranged_heap library.</p>"},{"location":"getting_started/quickstart/","title":"Quickstart","text":"<p>Here\u2019s a quick example to get you started with RangedHeap.</p> <p>From the ranged_heap module you can import the RangedHeap class, like:</p> <pre><code>import ranged_heap as rh\n\nrh.RangedHeap\n</code></pre>"},{"location":"getting_started/quickstart/#init-the-rangedheap","title":"Init the RangedHeap","text":"<pre><code># Define the range and initial choices\nk = 10  # Range of values (0 to 10)\nchoices = [(\"choice1\", 5), (\"choice2\", 3), (\"choice3\", 8)]\n\n# Initialize the RangedHeap\nheap = rh.RangedHeap(k, choices, min_=True)\n</code></pre>"},{"location":"getting_started/quickstart/#add-a-new-choice","title":"Add a new choice","text":"<pre><code>heap.add_choice(\"choice4\", 7)\n</code></pre>"},{"location":"getting_started/quickstart/#get-the-best-choice","title":"Get the best choice","text":"<pre><code>best_choice = heap.get_best()\nprint(f\"The best choice is: {best_choice}\")\n</code></pre>"},{"location":"getting_started/quickstart/#pop-the-best-choice","title":"Pop the best choice","text":"<pre><code>best_choice = heap.pop_best()\nprint(f\"The best choice popped is: {best_choice}\")\n</code></pre>"},{"location":"getting_started/quickstart/#delete-a-choice","title":"Delete a choice","text":"<pre><code>heap.delete_choice(\"choice4\", 7)\n</code></pre>"},{"location":"getting_started/quickstart/#adjust-the-value-of-a-choice","title":"Adjust the value of a choice","text":"<pre><code>heap.adjust_choice(\"choice1\", 5, 2)\n</code></pre>"},{"location":"getting_started/quickstart/#check-the-rangedheap-size","title":"Check the RangedHeap size","text":"<pre><code>size = len(heap)\nprint(f\"The number of choices in the heap is: {size}\")\n</code></pre>"},{"location":"helpers/wip/","title":"Wip","text":"<p>\ud83d\udea7 Work in Progress \ud83d\udea7</p> <p>This page is currently being developed and may not be complete.</p> <p>Feel free to contribute to this page! If you have suggestions or would like to help improve it, please contact us.</p>"},{"location":"user_guide/greedy_algorithms/","title":"Greedy Algorithms","text":"<p>Greedy algorithms build up a solution piece by piece, always choosing the next piece that offers the most immediate benefit. This local optimal choice is the hallmark of greedy algorithms. Some common examples of greedy algorithms include:</p> <ul> <li>Activity Selection Problem</li> <li>Fractional Knapsack Problem</li> <li>Prim\u2019s Minimum Spanning Tree</li> <li>Dijkstra\u2019s Shortest Path</li> </ul>"},{"location":"user_guide/greedy_algorithms/#why-rangedheap","title":"Why RangedHeap?","text":"<p>The RangedHeap data structure provides an efficient way to handle choices with integer values in the range [0, k]. It offers the following benefits that align well with the needs of greedy algorithms:</p> <ul> <li>Efficient Retrieval of Best Choice: The get_best() and pop_best() methods allow for quick retrieval of the minimum or maximum choice, which is essential for making the best local decision in greedy algorithms.</li> <li>Dynamic Updates: The add_choice(), delete_choice(), and adjust_choice() methods enable dynamic updates to the heap, which is necessary when the set of choices changes during the execution of the algorithm.</li> <li>Range Constraints: By constraining the choices to a specific range, RangedHeap ensures that the algorithm operates within the defined bounds, making it more efficient and easier to manage and optimize.</li> </ul>"},{"location":"user_guide/greedy_algorithms/#example-activity-selection-problem","title":"Example: Activity Selection Problem","text":"<p>The activity selection problem is a classic example where greedy algorithms are used. The goal is to select the maximum number of activities that don't overlap. Given a set of activities with start and end times, the greedy choice is to always pick the next activity that ends the earliest.</p>"},{"location":"user_guide/greedy_algorithms/#using-rangedheap","title":"Using RangedHeap","text":"<p>Here's how the RangedHeap can be used to solve the activity selection problem:</p> <ul> <li>Initialization: Create a RangedHeap with the end times of activities.</li> <li>Add Activities: Add each activity to the heap with its end time as the key.</li> <li>Select Activities: Use the pop_best() method to repeatedly select the activity with the earliest end time that doesn't overlap with the previously selected activity.</li> </ul> <pre><code>activities = [(1, 4), (2, 3), (3, 5), (0, 6), (5, 7), (8, 9)]\nk = max(end for _, end in activities)\nranged_heap = RangedHeap(k, [(i, end) for i, (_, end) in enumerate(activities)])\n\nselected_activities = []\nlast_end_time = -1\n\nwhile len(ranged_heap) &gt; 0:\n    best_activity_idx = ranged_heap.pop_best()\n    start, end = activities[best_activity_idx]\n    if start &gt;= last_end_time:\n        selected_activities.append((start, end))\n        last_end_time = end\n\nprint(\"Selected activities:\", selected_activities)\n</code></pre>"},{"location":"user_guide/greedy_algorithms/#conclusion","title":"Conclusion","text":"<p>The RangedHeap data structure is a powerful tool for implementing greedy algorithms when the choices are constrained to integer values within a specific range. Its efficient methods for adding, deleting, and retrieving the best choices make it particularly suitable for problems where the set of choices dynamically changes. By leveraging RangedHeap, one can implement optimized and efficient greedy solutions for a variety of problems.</p>"},{"location":"user_guide/greedy_algorithms/#references","title":"References","text":"<ul> <li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to Algorithms. MIT Press.</li> <li>Kleinberg, J., &amp; Tardos, \u00c9. (2005). Algorithm Design. Pearson.</li> </ul> <p>By understanding and utilizing the RangedHeap, developers can enhance their implementation of greedy algorithms, leading to more efficient and effective solutions.</p>"},{"location":"user_guide/introduction/","title":"Introduction","text":"<p>The RangedHeap data structure is designed to maintain a collection of choices associated with integer values within a specified range. This makes it particularly useful for greedy algorithms where the choices are integer-ranged (0-k). In this document, we will explore how the RangedHeap can be utilized in various greedy algorithm scenarios.</p>"}]}